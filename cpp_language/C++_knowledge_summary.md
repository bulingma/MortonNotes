<!-- TOC -->

- [C++的编程范式](#c的编程范式)
- [C++ 程序的生命周期—编码、预处理、编译、运行](#c-程序的生命周期编码预处理编译运行)
- [什么是面向对象（OOP）](#什么是面向对象oop)
- [什么是封装、继承、多态](#什么是封装继承多态)
- [常见的STL容器、算法](#常见的stl容器算法)
- [const的作用](#const的作用)
  - [1、const修饰基本数据类型，表示变量值不能改变](#1const修饰基本数据类型表示变量值不能改变)
  - [2、const初始化引用时的例外(非常规做法，忽略)](#2const初始化引用时的例外非常规做法忽略)
  - [3、顶层const和底层const](#3顶层const和底层const)
  - [4、const与函数](#4const与函数)
  - [5、const与类](#5const与类)
- [static的作用](#static的作用)
- [堆和栈的区别以及生命周期](#堆和栈的区别以及生命周期)
- [指针和引用的区别？](#指针和引用的区别)
- [new和malloc的区别？](#new和malloc的区别)
- [说下你对内存的了解](#说下你对内存的了解)
- [指针数组和数组指针](#指针数组和数组指针)
- [宏定义](#宏定义)
- [c++堆栈生长方向](#c堆栈生长方向)

<!-- /TOC -->
### C++的编程范式

**“编程范式”是一种“方法论”，就是指导你编写代码的一些思路、规则、习惯、定式和常用语。**

C++是在C语言的基础上开发的一种面向对象编程语言，应用广泛。C++支持多种编程范式：

**1、面向过程（ADT+PP）**

ADT:abstract data type; 抽象数据类型 
PP:procedure programming; 面向过程的编程范式 
ADT+PP 就是说面向过程的编程范式+抽象数据类型，你可以理解为c++的前身：带类的C。

 面向过程体现在 C++ 中，就是源自它的前身——C 语言的那部分，比如变量声明、表达式、分支 / 循环 / 跳转语句，等等。



**2、面向对象（object-oriented programming—OOP） **

OOP 这种编程风格起源于 Simula，**它依赖于封装（encapsulation）、继承（inheritance）以及多态（polymorphism）。**就C++而言，OOP 的意思是利用类层级（classhierarchies）及虚函数进行编程，从而可以通过精制的接口操作各种类型的对象，并且程序本身也可以通过派生（derivation）进行功能增量扩展。

请注意，OOP并非万能药。不要简单地把“OOP”等同于“好”。如果你的问题的基本要素中没有与生俱来的层级关系，那么类层级和虚函数对你的代码不会有任何帮助。**OOP 的优势在于类层级可以有效地表达很多问题；OOP的主要弱点在于太多人设法强行用层级模式解决问题。**并非所有问题都应该面向对象。也可以考虑使用**[普通类](http://stdcpp.cn/html/24/25/0612/179.htm)**（plain class）、**[泛型编程](http://stdcpp.cn/html/24/25/0701/195.htm)**和独立的函数（就像数学、C，以及 Fortran 中那样）作为解决问题的方案。

面向对象是 C++ 里一个基本的编程范式。**它的核心思想是“抽象”和“封装”**，倡导的是把任务分解成一些**高内聚低耦合**的对象，这些对象互相通信协作来完成任务。它**强调对象之间的关系和接口，而不是完成任务的具体步骤。**

 在 C++ 里，面向对象范式包括 **class**、**public**、**private**、**virtual**、**this** 等类相关的关键字，还有**构造函数**、**析构函数**、**友元函数**等概念。



**3、泛型编程（Generic Programming—GP）**

**泛型编程（Generic Programming,GP）是一种基于参数化（parameterization）的编程技巧**：可以使用类型参数化另一种类型（例如，vector的元素类型就是通过参数确定的）；算法也可以参数化另一种算法（例如，使用比较函数参数化排序函数）。GP的目的是将有用的算法或者数据结构尽可能地一般化，并使其最优化。

GP 在某些方面比 OOP要灵活得多。特别是，它不依赖于层级。例如，int 和 string 之间没有任何层级关系。总的来说，GP 的结构化程度更甚于OOP。事实上，GP 常被称为“参数多态（parametric polymorphism）”；而 OOP 常被称为“ad hoc 多态”。就C++ 而言，GP 于编译时就解析了所有名称；它不需要任何动态（运行时）调度。因此，GP 在对运行时效率要求很高的领域占据了主导地位。

泛型编程是自 STL（标准模板库）纳入到 C++ 标准以后才逐渐流行起来的新范式，**核心思想是“一切皆为类型”，或者说是“参数化类型” “类型擦除”，使用模板而不是继承的方式来复用代码，所以运行效率更高，代码也更简洁。**

在 C++ 里，泛型的基础就是 **template** 关键字，然后是庞大而复杂的标准库，里面有各种泛型容器和算法，比如 **vector**、**map**、**sort**等等。



**4、模版元编程**

这个词听起来好像很新，其实也有十多年的历史了，不过相对于前三个范式来说，确实“资历浅”。**它的核心思想是“类型运算”，操作的数据是编译时可见的“类型”。**所以也比较特殊，代码只能由编译器执行，而不能被运行时的 CPU 执行。

模板元编程是一种高级、复杂的技术，C++ 语言对它的支持也比较少，更多的是以库的方式来使用，比如**type_traits、enable_if** 等。



**5、函数式编程**

它几乎和“面向过程”一样古老，但却直到近些年才走入主流编程界的视野。所谓的“函数式”并不是 C++ 里写成函数的子程序，而是数学意义上、无副作用的函数，**核心思想是“一切皆可调用”，通过一系列连续或者嵌套的函数调用实现对数据的处理。**

函数式早在 C++98 时就有少量的尝试（bind1st/bind2nd 等函数对象），但直到 C++11 引入了 Lambda 表达式，它才真正获得了可与其他范式并驾齐驱的地位。



### C++ 程序的生命周期—编码、预处理、编译、运行

C++ 程序的生命周期是指整个C++程序**从编写到运行过程，除编码外都是由编译器完成。**

**C++ 程序的生命周期包括编码、预处理、编译、运行四个阶段**，它们都有各自的特点；
虽然我们只写了一个 C++ 程序，但里面的代码可能会运行在不同的阶段，分别由预处理器、编译器和 CPU 执行；

[01 | 重新认识C++：生命周期和编程范式](https://blog.csdn.net/GaoJuno23/article/details/106315069)

[C++的编程范式](https://www.cnblogs.com/aademeng/articles/7263505.html)



### 什么是面向对象（OOP）

面向对象是一种对现实世界（需求）理解和抽象的方法、思想、范式，**通过将需求要素转化为对象、进而使用封装、继承、多态进行问题处理的一种思想。**



### 什么是封装、继承、多态

* 1、封装

  封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。

  封装的意义在于保护或者防止代码（数据）被我们无意中破坏，从而实现**高内聚**的目的。

* 2、继承

  继承主要实现重用代码，节省开发时间。

  子类可以继承父类的一些东西。

* 3、多态

  同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。





### 常见的STL容器、算法

**STL包括两部分内容：容器和算法。**（重要的还有融合这二者的迭代器）

容器，即存放数据的地方。比如array等。

在STL中，**容器分为两类：序列式容器和关联式容器。**

**序列式容器，其中的元素不一定有序，但都可以被排序。**  

如：vector、list、deque、stack、queue、heap、priority_queue、slist；

**关联式容器，内部结构基本上是一颗平衡二叉树。所谓关联，指每个元素都有一个键值和一个实值，元素按照一定的规则存放。**  

如：RB-tree、set、map、multiset、multimap、hashtable、hash_set、hash_map、hash_multiset、hash_multimap。

下面各选取一个作为说明。

vector：它是一个动态分配存储空间的容器。区别于c++中的array，array分配的空间是静态的，分配之后不能被改变，而vector会自动重分配（扩展）空间。

set：其内部元素会根据元素的键值自动被排序。区别于map，它的键值就是实值，而map可以同时拥有不同的键值和实值。

算法，如排序，复制……以及个容器特定的算法。这点不用过多介绍，主要看下面迭代器的内容。

迭代器是STL的精髓，我们这样描述它：迭代器提供了一种方法，使它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构。它将容器和算法分开，好让这二者独立设计。

[20道必须掌握的C++面试题](https://www.w3cschool.cn/cpp/cpp-a9no2ppi.html)



### const的作用

```
1.const 修饰类的成员变量，表示成员常量，不能被修改。
2.const修饰函数承诺在本函数内部不会修改类内的数据成员，不会调用其它非 const 成员函数。
3.如果 const 构成函数重载，const 对象只能调用 const 函数，非 const 对象优先调用非 const 函数。
4.const 函数只能调用 const 函数。非 const 函数可以调用 const 函数。
5.类体外定义的 const 成员函数，在定义和声明处都需要 const 修饰符。
```

const 是 constant 的缩写，本意是不变的，不易改变的意思。在 C++ 中是用来**修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。**

C++ const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。**如果在编程中确实有某个值保持不变，就应该明确使用const，这样可以获得编译器的帮助。**

#### 1、const修饰基本数据类型，表示变量值不能改变

由于const一旦创建就不可更改，所以**const对象必须初始化**。

```
const int bufSize = 512;
bufSize = 512;              // 错误：试图向const对象写值
const int i = get_size();   // 正确
const int j = 42;           // 正确
const int k;                // 错误：未初始化
```

使用**值传递初始化**时，被初始化的对象是否为const与初始化对象是否为const无关。也即，const对象与非const对象可以互为初始化。）

```
int i = 0;
int j = i;       // 正确，非const初始化非const
const int k = i; // 正确，非const初始化const

const int x = 0;
int y = x;       // 正确，const初始化非const
const int z = x; // 正确，const初始化const
```

#### 2、const初始化引用时的例外(非常规做法，忽略)

#### 3、顶层const和底层const

通常在指针/引用与const符同时使用时会用到这个概念。**修饰指针本身的const称为顶层const，修饰指针所指向对象的const称为底层const。**底层const与顶层const是两个互相独立的修饰符，互不影响。

* 3.1. const与指针

指针本身是一个独立的对象，它又可以指向另一个对象。所以指针和const同时使用时，有两种情况：

```
int i = 0;
int *const j = &i; // 顶层const, 指针j指向i，const修饰指针j本身，所以j的地址值不允许修改，但可以通过j修改i的值
const int *k = &i; // 底层const, 指针k指向i，const修饰k指向的i，所以k的地址值可以修改，但不可以通过k修改i的值
```

* 3.2. const与引用

引用一旦初始化，就不能再修改（绑定），所以引用本身就具有"const"的性质。

与指针相比，引用相当于内置了顶层const。

所以使用引用时，就只需考虑是否为底层const：

```
int i = 0;
const int &j = i; // j为绑定到i的const引用，不允许使用j来修改i
```

* 3.3. 其他

(1). 可以将底层const的指针（或引用）指向（或绑定）到非const对象，但不允许非底层const的指针（或引用）指向（或绑定）到const对象。 （即：const对象不允许通过任何方式（指针/引用）被修改。）

(2). 修饰值本身的const均为顶层const：

```
const int i = 0; // 顶层const;
```

#### 4、const与函数

* 4.1. 值传递的const形参

```
void fcn(const int i) { /* ... */ }
```

这个函数中，变量i为值传递形参，根据值传递的初始化规则，**形参i是否为const与传入的实参是否为const是完全无关的。**这里的const仅表示i在函数体中不允许修改。

因为值传递的const形参在调用上与非const形参没有区别（大概是指，无论形参是否为const，实参都不会被修改。），所以仅仅使用const无法区分参数类别，所以无法实现函数重载，如下的重载是错误的：

```text
void fcn1(const int i) { /* ... */ }
void fcn1(int i) { /* ... */ } // 错误：重复定义函数，不能实现重载
```

* 4.2. const指针/引用的形参

对于顶层const的指针，与上一小节一样，其const性质与实参无关，顶层const仅表示指针/引用本身在函数体中不允许修改。

所以我们只需要讨论底层const的指针/引用。

```
void fcn2(const int &x) { /* ... */ } // 接受const或非const的int引用，但是不允许通过x修改传入的对象
void fcn2(const int *y) { /* ... */ } // 接受const或非const的int指针，但是不允许通过y修改传入的对象
```

如上两个函数都定义了底层const的形式参数，它们可以接受const或非const对象，但是不能在函数体内修改这些对象。所以如下的调用都是合法的：

```
int i = 0;
fcn2(i);  // 正确：调用第一个函数
fcn2(&i); // 正确：调用第二个函数

const int j = 0;
fcn2(j);  // 正确：调用第一个函数
fcn2(&j); // 正确：调用第二个函数
```

由于底层const描述实参性质（不允许在调用函数内部被修改），可以在调用时区分const，**所以使用底层const的指针/引用可以实现函数重载：**

```
void fcn3(int &x) { /* ... */ } 
void fcn3(const int &x) { /* ... */ } // 新函数，作用于const的引用
```

所以可以分别调用两个函数：

```
int i = 0;
fcn3(i); // 正确：调用第一个函数

const int j = 0;
fcn3(j); // 正确：调用第二个函数
```

注意，当传递非常量对象时，编译器会优先调用非常量版本的函数。

* 4.3. 总结

顶层const的形式参数不能实现函数重载，但底层const形参可以

当函数不修改参数值时，尽可能将形式参数定义为（底层）const参数。一方面，（底层）const参数可以保护参数对象；另一方面，因为（底层）const参数可以接受常量与非常量对象，但非（底层）const参数只能接受非常量对象。

#### 5、const与类

* 5.1. const与类的成员变量

​	一个类通常包含成员函数和成员变量。

1. 类的对象的const修饰表示该对象的成员变量不允许被修改。
2. 无论类的成员变量本身是否为const，只要对象声明为const，成员变量就不允许被修改。

```
class Number
{
  public:
    int number = 0;
};

int main()
{
    const Number n;
    n.number = 1; // 错误，n为const对象，不允许被修改
    return 0;
}
```

* 5.2. const与类的成员函数

  当对象被声明为const时，该对象不能调用非const函数，因为非const函数可能修改成员变量。

  ```
  class Number
  {
  public:
      void set(int num) { number = num; }
      int get() { return number; }
  
      int number = 0;
  };
  
  int main()
  {
      const Number n;
      n.set(1); // 错误，n为const对象，不能调用非const函数
      cout << n.get() << endl; // 错误，原因同上
      return 0;
  }
  ```

  1. 将成员函数声明为const函数，则可以被const对象调用，声明const函数的方法为在其参数列表后添加const关键字。
  2. const成员函数中不允许修改成员变量。也即，并非所有成员函数都可以被声明为const函数，C++会在编译时检查被声明为const的函数是否修改了成员变量，若是，则报错，编译不通过。

  ```
  class Number
  {
  public:
      void set(int num) const { number = num; } // 错误：const函数不允许修改成员变量
      int get() const { return number; } // 正确：没有修改成员变量，可被声明为const函数
  
      int number = 0;
  };
  
  int main()
  {
      const Number n;
      n.set(1);                // 错误，const函数不允许修改成员变量
      cout << n.get() << endl; // 正确，const对象可以调用const函数
      return 0;
  }
  ```

  与底层const形参一样，const成员函数也可以实现重载。同样，当非常量对象调用函数时，编译器会优先调用非常量版本的函数。

  ```
  class T
  {
  public:
      int fcn() { return 1; }
      int fcn() const { return 2; } // 正确：定义了可以重载的新函数
  };
  
  int main()
  {
      T t1;
      cout << t1.fcn() << endl; // 调用第一个函数，输出"1"
  
      const T t2;
      cout << t2.fcn() << endl; // 调用第二个函数，输出"2"
      return 0;
  }
  ```

* 5.3. 总结
  * 当函数不修改成员变量时，尽可能将函数声明为const函数，因为const函数可以被非const对象和const对象调用，而非const函数只能被非const对象调用。
  * const函数并不意味着数据安全，虽然不能通过const函数修改成员变量，但是这样的const仅为顶层const（即成员变量本身不能被修改），若成员变量包含非底层const的指针/引用，虽然成员变量本身不能被修改，但依然可以通过这些指针/引用修改其指向/绑定的对象。

* 5.4. const成员函数实现机制（详见文章）

[C++中的 const 关键字](https://zhuanlan.zhihu.com/p/37514756)



### static的作用

### 堆和栈的区别以及生命周期

* 一、堆栈空间分配区别：

1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；

2、堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。

* 二、堆栈缓存方式区别：

1、栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；

2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

* 三、堆栈数据结构区别：

堆（数据结构）：堆可以被看成是一棵树（最大堆、最小堆），如：堆排序；

栈（数据结构）：一种先进后出的数据结构（本质是list）。

[20道必须掌握的C++面试题](https://www.w3cschool.cn/cpp/cpp-a9no2ppi.html)



### 指针和引用的区别？

1. 指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用仅是个别名；

2. 引用使用时无需解引用(*)，指针需要解引用；

3. 引用只能在定义时被初始化一次，之后不可变；指针可变；

5. 引用不能为空，指针可以为空；

6. “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；

7. 指针和引用的自增(++)运算意义不一样；

8. 指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）
9. 从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。



### new和malloc的区别？

1、malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。

2、对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。

3、由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。

4、C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。

5、new可以认为是malloc加构造函数的执行。new出来的指针是直接带类型信息的。而malloc返回的都是void指针。

[20道必须掌握的C++面试题](https://www.w3cschool.cn/cpp/cpp-a9no2ppi.html)



### 说下你对内存的了解

1.栈 - 由编译器自动分配释放

2.堆 - 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收

3.全局区(静态区)，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。- 程序结束释放

4.另外还有一个专门放常量的地方。- 程序结束释放

5 程序代码区，存放2进制代码。

在函数体中定义的变量通常是在栈上，用malloc， calloc， realloc等分配内存的函数分配得到的就是在堆上。在所有函数体外定义的是全局量，加了static修饰符后不管在哪里都存放在全局区(静态区)，在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用，在函数体内定义的static表示只在该函数体内有效。另外，函数中的"adgfdf"这样的字符串存放在常量区。

[20道必须掌握的C++面试题](https://www.w3cschool.cn/cpp/cpp-a9no2ppi.html)


### 指针数组和数组指针  
前言：操作符的优先级：() > [] > *    
* 指针数组：它是一个数组，数组的元素都是指针。它是<u>**“储存指针的数组”**</u>的简称。  
* 数组指针：它是一个指针，它指向一个数组。它是<u>**“指向数组的指针”**</u>的简称。 

``` 
int *p1[10];;     // 指针数组
int (*p2)[10];    // 数组指针
```
“[]”的优先级比“*”要高。p1 先与“[]”结合，构成一个数组的定义，数组名为p1，int *修饰的是数组的内容，即数组的每个元素。那现在我们清楚，这是一个数组，其包含10 个指向int 类型数据的指针，即指针数组。  

至于p2 就更好理解了，在这里“（）”的优先级比“[]”高，“*”号和p2 构成一个指针的定义，指针变量名为p2，int 修饰的是数组的内容，即数组的每个元素。数组在这里并没有名字，是个匿名数组。那现在我们清楚p2 是一个指针，它指向一个包含10 个int 类型数据的数组，即数组指针。
我们可以借助下面的图加深理解：
![point_of_vector_OR_vector_point](../../z_images/design_partern/../../MortonNotes/z_images/point_of_vector_OR_vector_point.jpeg)  


[数组指针和指针数组的区别](https://zhuanlan.zhihu.com/p/55724052)
### 宏定义   
```
#define PLUS_TWO_NUM(a, b) return ((a) + (b))
```

### c++堆栈生长方向   

[堆、栈的地址高低？ 栈的增长方向？](https://www.zhihu.com/question/36103513)
