
<!-- TOC -->

- [Intel Optane Persistent Memory——PMem](#intel-optane-persistent-memorypmem)
- [持久内存主要优势场景](#持久内存主要优势场景)
  - [场景 1：大内存低成本解决方案](#场景-1大内存低成本解决方案)
  - [场景 2：高性能持久化需求的应用](#场景-2高性能持久化需求的应用)
  - [场景 3：内存数据持久性的应用](#场景-3内存数据持久性的应用)
- [持久内存使用模式](#持久内存使用模式)
  - [内存模式（Memory Mode）](#内存模式memory-mode)
  - [App Direct 模式（AD Mode）](#app-direct-模式ad-mode)
- [持久内存的参考案例](#持久内存的参考案例)
- [持久内存的开源项目](#持久内存的开源项目)
  - [Volatile libraries](#volatile-libraries)
  - [Persistent libraries](#persistent-libraries)
- [参考](#参考)

<!-- /TOC -->
## Intel Optane Persistent Memory——PMem
持久内存三个最重要的特征：大， 快，持久性：  
* 大：  
目前持久内存单条内存容量最大可以达到 512 GB，而目前服务器单条内存一般最多到 32/64 GB。也就是说，单台服务器使用持久内存可以轻松到达 TB 级别的内存容量。另一方面，单位价格来说，持久内存为普通内存的一半左右。

* 快：  
既然也号称为内存，那必然不能慢。可以看到，持久内存相比较于普通 SSD 有 1-2 个数量级的延迟性能优势，相比较于硬盘优势更加巨大。当然对比与 DRAM，其会有一定的性能差距。但是实际使用中由于性能瓶颈不一定在内存上，所以一般不会有特别明显的差距（一般性能衰退在一倍以内）。

* 持久性：  
通俗来说，就是持久内存有跟硬盘一样的特性，断电以后重启，内存中的数据依然存在。此项特性可以说是秒杀内存，内存中的数据我们都知道断电或者程序以外退出以后就不复存在。此项特性使得持久内存即可以当做一个高速持久化设备使用，也可以满足内存应用某些场景下的快速恢复的需求。

如下表格总结了对于数据中心单台服务器上的典型配置，以及相应的大致的性能数字作为参考。  

![存储介质性能](../../z_images/storage/存储介质性能.png)


## 持久内存主要优势场景
### 场景 1：大内存低成本解决方案
如果你的应用内存消耗量是关键，是整个系统的资源瓶颈，那么使用持久内存将会是你降低成本的最佳解决方案。你的系统一般在两种情况下对于大内存有特别的需求

1. 基于内存性能的考量，你必须使用基于内存的解决方案，而不可能使用基于磁盘的方案，比如内存数据库（Redis, MemSQL）。

2. 虽然你的应用可以接受基于磁盘而带来的性能损耗，但是显然如果内存扩大，你的应用可以跑得更快更加节省时间，比如基于 Spark 搭建的应用。

此种场景下，你可以考虑使用持久内存来提供一个大内存低成本的解决方案。

* 优势：  
  持久内存在单位价格上约为普通内存的一半，并且可以在单台机器上轻松达到 1.5 TB，甚至 3 TB 的内存大小。因此比如你目标需要 20 TB 的总内存容量，持久内存可能只需要10台机器即可满足，但是基于DDR内存的集群可能需要40台甚至更多。考虑机器投入以及运营上带来的成本，持久内存所带来的低成本解决方案的优势是显而易见的。

* 可能的问题：  
  当然引入持久内存，相比较于内存可能会带来一定的性能衰退，衰退的原因可能是持久内存本身所引起的，也可能是由于机器台数减少，其他硬件资源（比如CPU核数或者网络带宽）减少所引起的。所以实际项目落地中，作为决策者，一定需要进行谨慎评估，来量化持久内存带来的利害关系。

### 场景 2：高性能持久化需求的应用
持久内存作为一个内存和外存的混合体，其高速持久化的特性在某些磁盘 IO 作为性能瓶颈的场景下是一个破局的解法。虽然 SSD 一定程度上也可以缓解磁盘 IO 性能瓶颈，但是相比较于 PMem 这种可以实现两个数量级的吞吐和延迟改进的持久化设备来说，PMem 无疑是具有革命性的意义的。以下抛砖引玉举几个磁盘 IO 作为性能瓶颈的场景。

1. 消息队列：  
  大家熟悉的开源消息队列 Kafka，由于其消息持久化逻辑的存在，其吞吐最终会卡在硬盘 IO 上。目前的解法是不断堆机器来扩展整个 Kafka 集群的吞吐。

2. 搜索系统：  
  类似于 Kafka，流行的开源搜索系统 Elasticsearch，也将部分的数据结构存放在磁盘上。那么最终影响整体延迟和吞吐的将会是磁盘 IO 的性能。

3. 数据库或者 KV 存储引擎：  
  比如 MySQL 或者 RocksDB，都具有重要的面向外存的数据持久化逻辑。

4. 分布式文件系统：  
  在人工智能场景中，常常会有大量的小文件存在。比如在 Ceph 的文件系统中，在 metadata server 上对大量小文件的管理常常由于大量随机读写的存在而产生性能问题。

* 优势：  
  显然，对于有高速持久化读写需求的场景，持久内存引入直接有了数量级的性能提升。在吞吐方面，由于单机吞吐提升，因此总的机器数量规模可以大量减少，在延迟方面则是提供了另一给维度的优势。具体性能比对可以参照上一节末尾给出的性能比对表格。

* 可能的问题：  
  PMem 作为纯粹的持久化设备可能是把双刃剑，最主要的问题是其容量相比较于传统硬盘来说还是偏小，同时单位成本也高。因此对于某些场景下如果除了对于性能，对于容量也有较高的要求，那么使用 PMem 带来性能的提升，但是也可能会造成成本的上升。


### 场景 3：内存数据持久性的应用
这种场景下，本质上还是把 PMem 当做一个内存来使用，和上一个高性能持久化的场景有所相似有所区别。上一个场景主要是针对本来软件架构设计就有持久化逻辑（比如文件系统本来就需要存在硬盘上），然后我们把持久化逻辑搬移到 PMem 上就可以。其本身可能并不涉及到复杂的数据结构的修改，因为其本来的设计就已经带有了持久化逻辑。但是在场景 3 这种内存数据持久化场景中，软件本身的内存数据结构的设计是没有考虑到持久化逻辑的。因此你需要针对内存中的数据结构重新设计持久化数据结构和逻辑。这一类应用对开发的要求是最高的，同时也是最能完全发挥 PMem 的特点。

此种场景往往是本来就是基于纯内存的应用，但是希望增加数据持久的特性，最常见的需求是因为要快速数据恢复。此种需求一般来自线上服务系统（比如数据库 Redis，或者人工智能场景下的参数服务器、特征工程数据库等），线上服务一旦节点离线，都会造成服务质量的影响。由于系统是基于内存数据结构，离线以后的数据恢复往往需要小时级别的时间来重新抓取数据，并且重新构建内存中的数据结构。如果有了持久内存，此类服务不仅能够通过大内存降低成本，而且可以增加快速恢复功能，保证线上服务质量。

* 优势：  
  如上所述，此种模式下，可以把持久内存的优势充分发挥出来。首先大内存带来硬件成本的下降，其次，通过持久性，赋予了本来的内存应用的新的持久化特性，可以支持数据快速恢复，保证线上服务质量。

* 可能的问题：  
  此种应用唯一的问题可能是带来比较多的额外的开发工作量。一般的内存数据结构都没有持久化逻辑，一般要求程序员通过 PMDK 重新设计持久化数据结构和逻辑，实现期望中的内存数据持久化。

## 持久内存使用模式  
正是因为持久内存具有传统内存的特性，又兼具有外存的持久化特性，造就了其特殊的双模式使用方式。注意，两种模式不能混合使用，并且模式之间切换具有一定成本，无法做到程序运行时动态切换。  

### 内存模式（Memory Mode）
顾名思义，就是把持久内存直接当做内存使用，不利用其非易失特性。<u>这是一种最快速、低成本扩展内存容量的方式</u>，对于程序完全透明。具体来说，操作系统将会直接看到持久内存的容量，而原来的DRAM将会被隐藏掉（实际上作为了持久内存的一层cache，其cache机制由CPU直接掌控）。程序无需改动任何代码，可以直接利用持久内存的大内存优势来运行内存消耗大的应用。

内存模式使用简单，但是也带来了一些问题：

1. 可能的性能问题。由于DRAM被当做了PMem的一层cache，并且被CPU自动管理，但是PMem其在性能参数上是略低于DRAM的，所以在某些对于cache不友好的情况下，可能会带来性能较大的衰减。    
2. 无法使用持久化特性。内存模式丢失了内存数据持久化的特性，无法用作对数据持久化有要求的场景。  

### App Direct 模式（AD Mode）
AD Mode 实际上是把内存层级完全暴露给了应用。程序员需要自己控制将数据存放在DRAM或者持久内存，自己掌握是否要进行内存数据的持久化操作。因此，其优势正好是克服了内存模式的两个问题：

1. 存储层级对程序员可见，因此应用可以根据自己的特点进行存储性能优化，比如冷热数据的分级存储，以及使用缓存敏感的数据结构（cache conscious）；  
2. 数据持久性在AD Mode下可用，程序员可以选择是否将数据在持久内存上做持久化操作，从而达到利用高速持久化能力，或者给程序带来快速恢复的能力。   

但是，AD Mode 带来的问题在于研发成本的提升。由于持久化编程模型的引入，原来基于内存的程序可能需要重新架构才能在多级存储的内存架构上发挥优势。


## 持久内存的参考案例  
最后，作为一个新兴的技术，持久内存从2019年正式发布以后，正处在生根发芽的阶段，工业界已经有不少的成功案例可供参考，比如  
[快手推荐系统及 Redis 升级存储借傲腾™ 补上 DRAM 短板](https://www.intel.cn/content/www/cn/zh/architecture-and-technology/kuaishou-recommendation-system-and-redis-services-storage-upgrade.html)  
[百度 Feed 流服务借助傲腾™ 技术重构内存数据库](https://www.intel.cn/content/www/cn/zh/architecture-and-technology/baidu-feed-memory-database-restruction-with-optane-technology.html)  


## 持久内存的开源项目
持久内存相关的最重要的开源项目肯定是 Intel 自己家的 [Persistent Memory Programming](https://github.com/pmem) ，其中比较重要的几个repo包括：  
为了简化基于持久化内存的应用开发，Intel 开发和维护了 [Persistent Memory Development Kit](https://pmem.io/) 这个开源组件。虽然这个组件目前由 Intel 开发和维护，但是理论上 PMDK 是与具体的硬件平台无关的——虽然现在依然只有 Intel 的一款持久化内存量产了。

PMDK 中的库可以分成两大类：
* Volatile libraries  
  如果不关心数据的持久化，只想通过 persistent memory 扩展内存，可以使用这一类库。

* Persistent libraries    
  如果想要保证数据的 fail-safe，需要使用这一类库。  

### Volatile libraries 
[libmemkind](https://github.com/memkind/memkind) 提供 malloc 风格的接口，可以将持久化内存当成 DRAM 使用。  
[libvmemcache](https://pmem.io/vmemcache/manpages/master/vmemcache.3.html) 是一个针对持久化内存的特点优化的易失性 LRU 缓存。  

### Persistent libraries   
1. [libpmem](https://pmem.io/pmdk/libpmem/) 提供比较底层的操作持久化内存的接口，比如 pmem_map 类似 mmap、pmem_memcpy 类似 memcpy，具体可以参考官方文档。  
2. [libpmemobj](https://pmem.io/pmdk/libpmemobj/) 提供基于持久化内存的对象存储能力。  
3. [libpmemkv](https://pmem.io/pmemkv/) 是一个基于持久化内存的嵌入式 Key-Value 引擎，基于 B+ 树实现，针对读优化（libpmemkv 的内部实现）。  
4. [libpmemlog](https://pmem.io/pmdk/manpages/linux/master/libpmemlog/libpmemlog.7/) 提供 append-only 的日志文件接口。    
5. [libpmemblk](https://pmem.io/pmdk/libpmemblk/) 提供块存储接口，简单说就是将持久化内存抽象成一个数组。  

以上项目的源码在：[pmem](https://github.com/pmem) 


## 参考
[持久化内存调研](https://zhuanlan.zhihu.com/p/229211653)  
[持久内存（PMem）科普](https://zhuanlan.zhihu.com/p/391089447)