## 大页内存
其实大页内存是一种很通用的优化技术，它的优化方法就是避免快表缺失（避免TLB缺失）

* 页表  
为了保证进程能在内存中找到虚拟页对应的实际物理块，需要为每个进程维护一个映像表，即页表。页表记录了每一个虚拟页在内存中对应的物理块号。
在配置好了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。

* TLB(快表)
由于页表是存放在内存中的，这使CPU在每存取一个数据时，都要两次访问内存。第一次时访问内存中的页表，从中找到指定页的物理块号，再将块号与页内偏移拼接，以形成物理地址。第二次访问内存时，才是从第一次所得地址中获得所需数据。因此，采用这种方式将使计算机的处理速度降低近1/2。
为了提高地址变换速度，可在地址变换机构中，增设一个具有并行查找能力的特殊高速缓存，也即快表（TLB），用以存放当前访问的那些页表项。
**由于成本的关系，快表不可能做得很大，通常只存放16~512个页表项。**  

* 小页的困境
现代的计算机系统，都支持非常大的虚拟地址空间（2^32~2^64）。在这样的环境下，页表就变得非常庞大。**例如，假设页大小为4K，对占用40G内存的程序来说，页表大小为10M**，而且还要求空间是连续的。为了解决空间连续问题，可以引入二级或者三级页表。但是这更加影响性能，因为如果快表缺失，访问页表的次数由两次变为三次或者四次。由于程序可以访问的内存空间很大，如果程序的访存局部性不好，则会导致快表一直缺失，从而严重影响性能。
此外，由于页表项有10M之多，而快表只能缓存几百页，即使程序的访存性能很好，在大内存耗费情况下，快表缺失的概率也很大。
**那么，有什么好的方法解决快表缺失吗？大页内存！假设我们将页大小变为1G，40G内存的页表项也只有40，快表完全不会缺失！即使缺失，由于表项很少，可以采用一级页表，缺失只会导致两次访存。这就是大页内存可以优化程序性能的根本原因—快表几乎不缺失！**

*  大页内存的使用场景
任何优化手段都有它适用的范围，大页内存也不例外。前面我们一直强调，只有：
1、耗费的内存巨大；  
2、访存随机而且访存是瓶颈的程序；  
大页内存才会带来很明显的性能提升。
网上的例子一直在用Oracle数据库作为例子不是没有道理的，这是因为Oracle数据库耗费的内存也很巨大，而且数据库的增删查改也缺乏局部性。数据库背后的增删查改基本上是对B树进行操作，树的操作一般缺少局部性。
什么样的程序局部性较差呢？我个人认为采用哈希和树策略实现的程序往往具有较差的访存局部性，这时如果程序性能不好可以尝试大页内存。相反，单纯的数组遍历或者图的广度遍历等操作，具有很好的访存局部性，采用大页内存很难获得性能提升。

[大页内存(HugePages)在通用程序优化中的应用](https://blog.csdn.net/yutianzuijin/article/details/41912871)