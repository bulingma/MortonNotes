
<!-- TOC -->

- [动态规划的解题步骤](#动态规划的解题步骤)
- [背包递推公式](#背包递推公式)
- [内、外循环的顺序](#内外循环的顺序)
- [内循环遍历顺序](#内循环遍历顺序)
- [题目汇总](#题目汇总)
  - [基础题目](#基础题目)
    - [509.斐波那契数 (AC)](#509斐波那契数-ac)
      - [题目](#题目)
      - [题解](#题解)
      - [代码](#代码)
    - [70.爬楼梯（AC）](#70爬楼梯ac)
      - [题目](#题目-1)
      - [题解](#题解-1)
      - [代码](#代码-1)
    - [746.使用最小花费爬楼梯(AC)](#746使用最小花费爬楼梯ac)
      - [题目](#题目-2)
      - [题解](#题解-2)
      - [代码](#代码-2)
    - [62.不同路径(AC)](#62不同路径ac)
      - [题目](#题目-3)
      - [题解](#题解-3)
      - [代码](#代码-3)
    - [63.不同路径2(AC)](#63不同路径2ac)
      - [题目](#题目-4)
      - [题解](#题解-4)
      - [代码](#代码-4)
    - [343.整数分拆（AC）](#343整数分拆ac)
      - [题目](#题目-5)
      - [题解](#题解-5)
      - [代码](#代码-5)
    - [96.不同的二叉搜索树（难题）](#96不同的二叉搜索树难题)
      - [题目](#题目-6)
      - [题解](#题解-6)
      - [代码](#代码-6)
  - [背包问题](#背包问题)
    - [01背包](#01背包)
      - [416.分割等和子集](#416分割等和子集)
      - [1049. 最后一块石头的重量 II](#1049-最后一块石头的重量-ii)
      - [474.一和零](#474一和零)
      - [494.目标和](#494目标和)
    - [完全背包](#完全背包)
      - [377. 组合总和 IV](#377-组合总和-iv)
      - [518.零钱兑换II](#518零钱兑换ii)
      - [322.零钱兑换](#322零钱兑换)
      - [279.完全平方数](#279完全平方数)
      - [70. 爬楼梯进阶版(完全背包)](#70-爬楼梯进阶版完全背包)
      - [139.单词拆分](#139单词拆分)
    - [多重背包](#多重背包)
      - [打家劫舍（待完成）](#打家劫舍待完成)
        - [198.打家劫舍](#198打家劫舍)
        - [213.打家劫舍2](#213打家劫舍2)
        - [337.打家劫舍3](#337打家劫舍3)
      - [4、股票问题（待完成）](#4股票问题待完成)
      - [121.买卖股票的最佳时机（只能买卖一次）](#121买卖股票的最佳时机只能买卖一次)
      - [122.买卖股票的最佳时机2（可以买卖多次）](#122买卖股票的最佳时机2可以买卖多次)
      - [123.买卖股票的最佳时机3（最多买卖两次）](#123买卖股票的最佳时机3最多买卖两次)
      - [188.买卖股票的最佳时机4（最多买卖K次）](#188买卖股票的最佳时机4最多买卖k次)
      - [309.最佳买卖股票时机含冷冻期（买卖多次，卖出有一天冷冻期）](#309最佳买卖股票时机含冷冻期买卖多次卖出有一天冷冻期)
      - [714.最佳买卖股票时机含手续费（买卖多次，每次有手续费）](#714最佳买卖股票时机含手续费买卖多次每次有手续费)
      - [5、子序列问题（待完成）](#5子序列问题待完成)
      - [5.1、子序列（不连续）](#51子序列不连续)
        - [300.最长上升子序列](#300最长上升子序列)
        - [1143.最长公共子序列](#1143最长公共子序列)
        - [1035.不相交的线](#1035不相交的线)
      - [5.2、子序列（连续）](#52子序列连续)
        - [674.最长连续递增序列](#674最长连续递增序列)
        - [718.最长重复子数组](#718最长重复子数组)
        - [53.最大子序和](#53最大子序和)
      - [5.3、编辑距离](#53编辑距离)
        - [392.判断子序列](#392判断子序列)
        - [115.不同的子序列](#115不同的子序列)
        - [583.两个字符串的删除操作](#583两个字符串的删除操作)
        - [72.编辑距离](#72编辑距离)
      - [5.4、回文](#54回文)
        - [647.回文子串](#647回文子串)
        - [516.最长回文子序列](#516最长回文子序列)
    - [](#)

<!-- /TOC -->

## 动态规划的解题步骤

- **1、确定dp数组(dp table)以及下标的含义**；
- **2、确定递推公式**；
- **3、dp数组如何初始化**；
- **4、确定遍历顺序**；
- **5、举例推导dp数组**；



## 背包递推公式

* 问能否能装满背包(或者最多装多少): 

  dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); 

  对应题目如下:

  动态规划:416.分割等和子集

  动态规划:1049.最后一块石头的重量 II



* 问装满背包有几种方法: 

  dp[j] += dp[j - nums[i]] 

  对应题目如下:

  动态规划:494.目标和

  动态规划:518. 零钱兑换 II 动态规划:377.组合总和IV

  动态规划:70. 爬楼梯进阶版(完全背包)



* 问背包装满最大价值:

  dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 

  对应题目如下:

  动态规划:474.一和零

  

* 问装满背包所有物品的最小个数:

  dp[j] = min(dp[j - coins[i]] + 1, dp[j])；

  对应题目如下:

  动态规划:322.零钱兑换

  动态规划:279.完全平方数



## 内、外循环的顺序

求排列时需要将背包（target）放在外循环，将物品（nums）放在内循环。(377. 组合总和 IV)

求组合时需要将物品（nums）放在外循环，将背包（target）放在内循环。(518.零钱兑换II)

要求价值最少/大时，两个循环的先后顺序就无所谓了。 (322.零钱兑换)



## 内循环遍历顺序

每一步可以走多次，这是<u>完全背包</u>，内循环需要从前向后遍历。(322.零钱兑换)

每一步可以走一次，这是<u>01背包</u>，内循环需要从后向前遍历。(见01背包)





## 题目汇总

### 基础题目

#### 509.斐波那契数 (AC)

##### 题目

**斐波那契数**，通常用 `F(n)` 表示，形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给你 `n` ，请计算 `F(n)` 。



##### 题解

- **1、确定dp数组以及下标的含义**；

  dp[i]定义： 表示斐波那契数列第i项（F(i)）的值；

- **2、确定递推公式**；

    F(0) = 0，F(1) = 1
    F(n) = F(n - 1) + F(n - 2)，其中 n > 1

- **3、dp数组初始化**；

  dp[0] = 0;
  dp[1] = 1;

- **4、确定遍历顺序**；

  由于dp[n] = dp[n-1] + dp[n-2] ，所以遍历顺序一定是从前往后

- **5、举例推导dp数组**；



##### 代码

````cpp
class Solution{
public:
	int fib(int n){
    if(n < 2){
      return n;
    }
    
    std::vecter<int> dp(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    for(int i = 2; i <= n; i++){
      dp[i] = dp[i-2] + dp[i - 1];
    }
    return dp[n];
  }
}
````



#### 70.爬楼梯（AC）

##### 题目

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。



##### 题解

* 1、确定dp数组及下标含义

  dp[i] 表示爬到楼梯i的不同方式总和

* 2、递推公式

  dp[i] = dp[i-1] + dp[i-2];

* 3、确定遍历顺序

  从前往后

* 4、dp数组初始化

  dp[0] = 0;

  dp[1] = 1;

  dp[2] = 2;

* 5、举例推导dp数组



##### 代码

```cpp
class Solution{
public:
	int climbStairs(int n){
		if(n < 2){
      return n;
    }
    
    std::vecter<int> dp(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    dp[2] = 2;
    for(int i = 3; i <= n; i++){
      dp[i] = dp[i-2] + dp[i - 1];
    }
    return dp[n];
	}
}

// 如果每次可以爬1，2，3....m阶，则总共有多少种方法？
class Solution{
public:
	int climbStairs(int n){
		if(n < 2){
      return n;
    }
    
    std::vecter<int> dp(n + 1);
    dp[0] = 1;
    int m = 2;
    for(int i = 1; i <= n; i++){
      for(int j = 1; j <= m; j++){
        if(i - j >= 0){
          dp[i] += dp[i-j];
        }
      }
    }
    return dp[n];
	}
}
```



#### 746.使用最小花费爬楼梯(AC)

##### 题目

数组的每个下标作为一个阶梯，第 `i` 个阶梯对应着一个非负数的体力花费值 `cost[i]`（下标从 `0` 开始）。

每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。

请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。

**示例 1：**

```
输入：cost = [10, 15, 20]
输出：15
解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。
```

 **示例 2：**

```
输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出：6
解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。
```



##### 题解

* 1、dp数组下标及含义

  dp[i]：爬到阶梯i，所花费的最小体力值

* 2、递推公式

  dp[i] = min(dp[i-2]+cost[i-2], dp[i-1]+cost[i-1])

* 3、dp数组初始化

  dp[0] = 0;

  dp[1] = 0;

  dp[2] =  min(dp[0]+cost[0], dp[1]+cost[1]);

* 4、确定遍历顺序

  从左往右

* 5、打印dp数组



##### 代码

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int len = cost.size();
        vector<int>dp(len + 1); // dp[i]表示达到第i阶台阶对应的最小总花费

        //状态转移方程
        // dp[i] = min{dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]}
        // i > 2
        dp[0] = 0;
        dp[1] = 0;
        dp[2] = min(dp[0]+cost[0], dp[1]+cost[1]);
        if(len < 3){
            return dp[len]; 
        }
        for(int i = 3; i <= len; i++){
            dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]);
        }
        return dp[len];
    }
};
```





#### 62.不同路径(AC)

##### 题目

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？



##### 题解

* 1、dp数组下标及含义

  `dp[i][j]`：机器人爬到阶梯i，j 总共有`dp[i][j]`条路径

* 2、递推公式

  ```
  dp[i][j] = dp[i-1][j] + dp[i][j-1]
  ```

* 3、dp数组初始化

  `dp[0][j]` = 1;

  `dp[i][0]` = 1;

* 4、确定遍历顺序

  从左往右，从上到下

* 5、打印dp数组



##### 代码

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        //1、dp数组定义及下标含义:dp[i][j]表示到达位置i，j的不同路径数
        vector<vector<int>>dp(m, vector<int>(n));
        //2、状态转移方程
        // dp[i][j] = dp[i-1][j] + dp[i][j-1]
        //3、dp数组初始化
        for(int i = 0; i < m; i++){
            dp[i][0] = 1;
        }
        for(int j = 0; j < n; j++){
            dp[0][j] = 1;
        }
        if(m <= 1 || n <= 1){
            return dp[m - 1][n - 1];
        }
        //4、dp数组遍历
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```



#### 63.不同路径2(AC)

##### 题目

一个机器人位于一个 *m x n* 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

![image-20220315103402624](/Users/myg/Library/Application Support/typora-user-images/image-20220315103402624.png)

```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

##### 题解

* 1、dp数组下标及含义

  `dp[i][j]`：机器人爬到阶梯i，j 总共有`dp[i][j]`条路径

* 2、递推公式

  ```
  dp[i][j] = dp[i-1][j] + dp[i][j-1]
  ```

* 3、dp数组初始化

  ```cpp
  vector<vector<int>> dp(m, vector<int>(n, 0));
  
  for(int i = 0; i < m; i++){
    if (obstacleGrid[i][0]) {
    	break;
    }eles{
     	dp[i][0] = 1;
    }  
  }
  
  for(int i = 0; i < n; i++){
    if (obstacleGrid[0][i]) {
    	break;
    }eles{
     	dp[0][i] = 1;
    }  
  }
  ```

  

* 4、确定遍历顺序

  从左往右，从上到下

* 5、打印dp数组



##### 代码

```CPP
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        //dp[i][j]表示达到位置i，j的路径总数
        for(int i = 0; i < m; i++) {
            if(obstacleGrid[i][0]){
                break;
            }
            dp[i][0] = 1;
        }
        for(int j = 0; j < n; j++) {
            if(obstacleGrid[0][j]){
                break;
            }
            dp[0][j] = 1;
        }
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                if(!obstacleGrid[i][j]){
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                }else{
                    dp[i][j] = 0;
                }
            }
        }
        return dp[m-1][n-1];
    }
};
```



#### 343.整数分拆（AC）

##### 题目

给定一个正整数 *n*，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

**示例 1:**

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

**说明:** 你可以假设 *n* 不小于 2 且不大于 58。



##### 题解

* 1、dp数组下标及含义

  dp[i]：整数 i 被拆分成的多个正整数之和，多个正整数乘积的最大值

* 2、递推公式

  ```
  // j从1开始遍历
  // dp[i] = max({dp[i], (i - j) * j, dp[i - j] * j});
  
  在取最大值的时候，为什么还要比较dp[i]呢？
  因为在递推公式推导的过程中，每次计算dp[i]时取最大的而已（因为有for循环找最大的dp[i]）。
  ```

* 3、dp数组初始化

  dp[0] = 0;

  dp[1] = 1;

  dp[2] = 1;

* 4、确定遍历顺序

  从左往右

* 5、打印dp数组



##### 代码

```cpp
// @lc code=start
class Solution {
public:
    int integerBreak(int n) {
        // 1、dp数组定义以及下标含义
        // dp[i]含义为：分拆数字i时，这些整数乘积的最大值为dp[i]

        // 2、状态转移方程
        // j从1开始遍历
        // dp[i] = max(j * dp[i-j], j * (i - j))

        // 3、dp初始化
        vector<int>dp(n+1);
        dp[2] = 1;
        for(int i = 3; i <= n; i++){
            for(int j = 1; j < i - 1; j++){
                dp[i] = max(dp[i], max(j * (i-j), j * dp[i - j]));
            }
        }
        return dp[n];
    }
};
```





#### 96.不同的二叉搜索树（难题）

##### 题目

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

示例1:

![image-20220315110548177](/Users/myg/Library/Application Support/typora-user-images/image-20220315110548177.png)



```
输入：n = 3
输出：5
```

**示例 2：**

```
输入：n = 1
输出：1
```



##### 题解

* 1、dp数组及下表含义
* 2、递推公式
* 3、dp数组初始化
* 4、遍历顺序
* 5、打印dp数组

##### 代码

```cpp
class Solution {
public:
    int numTrees(int n) {
        // 1、确定dp数组及下标含义
        // dp[i]表示由i个节点组成的二叉搜索树的种类（1到i为节点组成的二叉搜索树的个数为dp[i]。）
        vector<int>dp(n + 1);

        // 2、确定状态转移方程
        // dp[i]+ = dp[j-1]*dp[i-j] 
      	// (j-1意义为以j为头结点左子树节点数量，i-j为以j为头结点右子树节点数量) 
      
        // 3、dp数组初始化
        // dp[1] = 1
        // dp[2] = dp[0]*dp[1] + dp[1]*dp[0]
        // dp[3] = dp[0]*dp[2] + dp[2]*dp[0] + dp[1]*dp[1]

        // 4、dp数组遍历顺序
        dp[0] = 1;
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= i; j++){
                dp[i] += dp[j-1]*dp[i-j]; 
            }
        }
        return dp[n];
    }
};
```







### 背包问题

#### 01背包

##### 416.分割等和子集 

* 题目

  给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

   

  **示例 1：**

  ```
  输入：nums = [1,5,11,5]
  输出：true
  解释：数组可以分割成 [1, 5, 5] 和 [11] 。
  ```

  **示例 2：**

  ```
  输入：nums = [1,2,3,5]
  输出：false
  解释：数组不能分割成两个元素和相等的子集。
  ```

   

  **提示：**

  - `1 <= nums.length <= 200`
  - `1 <= nums[i] <= 100`



* 代码

  ```cpp
  class Solution {
  public:
      bool canPartition(vector<int>& nums) {
          // 1、dp数组下标及含义
          // dp[j]，在01背包中，dp[j]表示，容量为j的背包，所背的物品的最大价值为dp[j]
          // dp[j]，在本题中，dp[j]表示，容量为j的背包，最大可以凑成j的子集总和为dp[j]
  
          // 2、递推公式
          // 01背包的递推公式为:dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
          // 本题，相当于背包中放入数值，数值i的重量为nums[i]，value也为nums[i]
          // 所以递推公式为，dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])
  
          // 3、dp数组初始化
          int len = nums.size();
          int target = 0;
          for(int i = 0; i < len; i++){
              target += nums[i];
          }
          if (target % 2 == 1) return false;
          target = target / 2;
          vector<int> dp(target + 1, 0);
  
          // 4、dp数组遍历    
          for(int i = 0; i < len; i++){  // 遍历物品
              for(int j = target; j >= nums[i] ; j--){ // 遍历背包
                  dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
              }
          }
          if(dp[target] == target)
              return true;
          return false;
      }
  };
  ```

  

##### 1049. 最后一块石头的重量 II 

* 题目

  有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

  每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

  - 如果 `x == y`，那么两块石头都会被完全粉碎；
  - 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

  最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

   

  **示例 1：**

  ```
  输入：stones = [2,7,4,1,8,1]
  输出：1
  解释：
  组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
  组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
  组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
  组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
  ```

  **示例 2：**

  ```
  输入：stones = [31,26,33,21,40]
  输出：5
  ```

  **示例 3：**

  ```
  输入：stones = [1,2]
  输出：1
  ```

   

  **提示：**

  - `1 <= stones.length <= 30`
  - `1 <= stones[i] <= 100`

  

*  代码

  ```cpp
  class Solution {
  public:
      int lastStoneWeightII(vector<int>& stones) {
          //1、dp数组及下标含义： dp[j]表示容量为j的背包，最多可以背dp[j]这么重的石头
          //2、递推公式：dp[j] = max(dp[j], dp[j-stones[i]]+stones[i])
          //3、dp数组初始化
          //4、dp数组遍历
          int len = stones.size();
          int weight = 0;
          for(int i = 0; i < len; i++){
              weight += stones[i];
          }
          int package = weight/2;
          //由于package肯定是向下取整的，所以dp[package]是一半总重量的石头中那些石头组合的重量的最大值
          vector<int>dp(package + 1, 0);
          for(int i = 0; i < len; i++){
              for(int j = package; j >= stones[i]; j--){
                  dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
              }
          }
          return weight - (dp[package] * 2);
      }
  };
  ```

  

##### 474.一和零

* 题目

  给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

  请你找出并返回 `strs` 的最大子集的大小，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

  如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

   

  **示例 1：**

  ```
  输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
  输出：4
  解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
  其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
  ```

  **示例 2：**

  ```
  输入：strs = ["10", "0", "1"], m = 1, n = 1
  输出：2
  解释：最大的子集是 {"0", "1"} ，所以答案是 2 。
  ```

   

  **提示：**

  - `1 <= strs.length <= 600`

  - `1 <= strs[i].length <= 100`

  - `strs[i]` 仅由 `'0'` 和 `'1'` 组成

  - `1 <= m, n <= 100`

    

* 代码

  ```cpp
  class Solution {
  public:
      int countCharacter(std::string res, char character) const {
          int result = 0;
          int point = 0;
          while(res[point]){
              if(res[point] == character){
                  result++;
                  point++;
              }
          }
          return result;
      }
      int findMaxForm(vector<string>& strs, int m, int n) {
          vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
          for(string str : strs){
              int zero_nums = 0;
              int one_nums = 0;
              for (char c : str) {
                  if (c == '0') zero_nums++;
                  else one_nums++;
              }
              for(int j = m; j >= zero_nums; j--){
                  for(int k = n; k >= one_nums; k--){
                      dp[j][k] = max(dp[j][k], dp[j - zero_nums][k - one_nums] + 1);
                  }
              }
          }
          return dp[m][n];
      }
  };
  ```

  

  

##### 494.目标和

* 题目

  给你一个整数数组 `nums` 和一个整数 `target` 。

  向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

  - 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

  返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

   

  **示例 1：**

  ```
  输入：nums = [1,1,1,1,1], target = 3
  输出：5
  解释：一共有 5 种方法让最终目标和为 3 。
  -1 + 1 + 1 + 1 + 1 = 3
  +1 - 1 + 1 + 1 + 1 = 3
  +1 + 1 - 1 + 1 + 1 = 3
  +1 + 1 + 1 - 1 + 1 = 3
  +1 + 1 + 1 + 1 - 1 = 3
  ```

  **示例 2：**

  ```
  输入：nums = [1], target = 1
  输出：1
  ```

   

  **提示：**

  - `1 <= nums.length <= 20`
  - `0 <= nums[i] <= 1000`
  - `0 <= sum(nums[i]) <= 1000`
  - `-1000 <= target <= 1000`

* 代码

  ```cpp
  class Solution {
  public:
      int findTargetSumWays(vector<int>& nums, int target) {
          int len = nums.size();
          int sum = 0;
          for(int i = 0; i < len; i++){
              sum += nums[i];
          }
          // left + right = sum;
          // left - right = target;
          // left - (sum - left) = target; -> (target + sum)/2 = left
          if((target + sum)%2 == 1){
              return 0;
          }
          if(target > sum){
              return 0;
          }
          //1. 确定dp数组以及下标的含义 dp[j]表示:填满j(包括j)这么大容积的包，有dp[j]种方法
          //2. 递推公式： dp[j] += dp[j - nums[i]]
          //3. 初始化，dp[0] = 1,d[1...n] = 0
  
          int left = (target + sum) / 2;
          vector<int>dp(left + 1, 0);
          dp[0] = 1; 
  
          for(int i = 0; i < len; i++){
              for(int j = left; j >= nums[i]; j--){
                  dp[j] += dp[j-nums[i]];
              }
          }
          return dp[left];
      }
  };
  ```

  

#### 完全背包

##### 377. 组合总和 IV

##### 518.零钱兑换II

##### 322.零钱兑换

##### 279.完全平方数

##### 70. 爬楼梯进阶版(完全背包)

##### 139.单词拆分



#### 多重背包

##### 打家劫舍（待完成）

###### 198.打家劫舍

###### 213.打家劫舍2

######  337.打家劫舍3

##### 4、股票问题（待完成）

##### 121.买卖股票的最佳时机（只能买卖一次）

##### 122.买卖股票的最佳时机2（可以买卖多次）

##### 123.买卖股票的最佳时机3（最多买卖两次）

##### 188.买卖股票的最佳时机4（最多买卖K次）

##### 309.最佳买卖股票时机含冷冻期（买卖多次，卖出有一天冷冻期）

##### 714.最佳买卖股票时机含手续费（买卖多次，每次有手续费）

##### 5、子序列问题（待完成）

##### 5.1、子序列（不连续）

######  300.最长上升子序列

###### 1143.最长公共子序列

###### 1035.不相交的线

##### 5.2、子序列（连续）

######  674.最长连续递增序列

######  718.最长重复子数组

######  53.最大子序和

##### 5.3、编辑距离

######  392.判断子序列

######  115.不同的子序列

######  583.两个字符串的删除操作

######  72.编辑距离

##### 5.4、回文

######  647.回文子串

######  516.最长回文子序列 

#### 



